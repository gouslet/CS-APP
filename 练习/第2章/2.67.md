2.67 给你一个任务，编写一个过程int_size_is_32()，当在一个int 是32位的机器上运行时，该程序产生1，而其他情况则产生0。不允许使用sizeof运算符。下面是开始时的尝试：
```c
1 /* The following code does not run properly on some machines */
2 int bad_int_size_is_32() {
3 /* Set most significant bit (msb) of 32-bit machine */
4 int set_msb = 1 << 31;
5 /* Shift past msb of 32-bit word */
6 int beyond_msb = 1 << 32;
8 /* set_msb is nonzero when word size>= 32 beyond_msb is zero when word size<= 32 */
9 return set_msb && !beyond_msb;
11 }
```
当在SUN SPARC这样的32位机器上编译并运行时，这个过程返回的却是0。下面的编译器信息给了我们一个问题的指示：
`warning: left shift count>= width of type`  
A. 我们的代码在哪个方面没有遵守C语言标准？
B. 修改代码，使得它在int 至少为32位的任何机器上都能正确地运行。
C. 修改代码，使得它在int至少为16位的任何机器上都能正确地运行。  
解：  
A. C语言在许多机器上通过计算`k mod w`后移动k位来执行移动k位，但在SUN SPARC机器上是个例外   
B. 
```c
/* The following code runs properly on some machines where size of int is at least 32*/
int int_size_is_32() {
    /* Set most significant bit (msb) of 32-bit machine */
    int set_msb = INT_MIN;
    /* Shift past msb of 32-bit word */
    int beyond_msb = set_msb << 1;
    /* set_msb is nonzero when word size>= 32 beyond_msb is zero when word size<= 32 */
    return set_msb && !beyond_msb;
}
```
C. 
```c
/* The following code runs properly on some machines where size of int is at least 16*/
int int_size_is_32() {
    /* Set most significant bit (msb) of 32-bit machine */
    int set_msb = 1 << 31;
    /* Shift past msb of 32-bit word */
    int beyond_msb = 1 << 15;
    beyond_msb  <<= 15;
    beyond_msb  <<= 2;
    /* set_msb is nonzero when word size>= 32 beyond_msb is zero when word size<= 32 */
    return set_msb && !beyond_msb;
}
```