在练习题2.10 中的inplace_swap 函数的基础上，你决定写一段代码，
实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数：
```
void reverse_array(int a[], int cnt) {
    int first, last;
    for (first= 0, last= cnt-1;first<= last;
            first++,last--)
    inplace_swap(&a[first], &a[last]);
}
```
对一个包含元素1、2、3和4的数组使用这个函数时，正如预期的那样，现在数组的元素变成了4、3、2和1。不过，当对一个包含元素1、2、3、4和5的数组使用这个函数时，会很惊奇地看到得到数字的元素为5、4、0、2和1 。实际上，会发现这段代码对所有偶数长度的数组都能正确地工作，但是当数组的长度为奇数时，它就会把中间的元素设置成0。

A. 对于一个长度为奇数的数组，长度cnt=2k+1,
循环中，变量first 和last 的值分别是什么？    
B. 为什么这时调用函数inplace_swap会将数组元素设置为0?  
C. 对reverse_array 的代码做哪些简单改动就能消除这个问题？

解：  
A. 
$$
\begin{aligned}
first &= n, n \in [0,k]\\
last &= 2k-n, n \in [0,k]\\
\end{aligned}
$$ 

B. 因为最后一次循环时，first和last的值均为k，即指向同一个元素，则在调用inplace_swap后的第一个步骤中该位置的元素被置为0了，之后的步骤中均为对0进行抑或运算，结果仍然为0

C. 可以将 reverse_array函数中for循环的中止判断条件修改为first < last，即可消除该问题