2.63 将下面的C函数代码补充完整。函数`srl`用算术右移（由值`xsra`给出）来完成逻辑右移，后面的其他操作不包括右移或者除法。函数sra用逻辑右移（由值xsrl给出）来完成算术右移，后面的其他操作不包括右移或者除法。  
可以通过计算`8*sizeof(int)`来确定数据类型`int`中的位数`w`。  
位移量k的取值范围为$0\sim \omega-1$。  
```c    
unsigned srl(unsigned x, int k) {
/* Perform shift arithmetically */
    unsigned xsra = (int) x >> k;
    int w = 8 * sizeof(int);
    return ((0x1 << (w - k)) - 1) & xsra;        
}
```   
```c    
int sra(int x, int k) {
    /* Perform shift logically*/
    int xsrl = (unsigned) x >> k;
    int w = 8 * sizeof(int);
    int mask = (1 << k) - 1 << (w - k)
    sign = x & 1 << (w - 1)
    sign && xsrl |= mask
    return xsrl;
}
```
解：
1. `0x1 << (w - k)) - 1`得到高`k`位为`0`、低`w-k`位为`1`的整数，与`xsra`相与将其高位置为`0`,即实现了将`unsigned x`逻辑右移`k`位。
2. `mask`高`k`位为`1`，低`w-k`位为`0`，`sign`为标志位，若`sign`为`1`，则`xsrl |= mask`将`xsrl`高`k`位置为`1`；若`sign`为`0`，则逻辑右移与算术右移一样。即实现了将`int x`算数右移`k`位。