2.72 给你一个任务，写一个函数，将整数`val`复制到缓冲区`buf`中，但是只有当缓冲区中有足够可用
的空间时，才执行复制。你写的代码如下：
```c
/* Copy integer into buffer if space is available */
/* WARNING: The following code is buggy */
void copy_int(int val, void *buf, int maxbytes) {
    if (maxbytes-sizeof(val) >= 0)
        memcpy(buf, (void*) &val, sizeof(val));
}
```
这段代码使用了库函数`memcpy`。虽然在这里用这个函数有点刻意，因为我们只是想复制一个`int`, 但是它说明了一种复制较大数据结构的常见方法。
你仔细地测试了这段代码后发现，哪怕`maxbytes`很小的时候，它也能把值复制到缓冲区中。  
A. 解释为什么代码中的条件测试总是成功。提示： `sizeof`运算符返回类型为`size_t`的值。  
B. 你该如何重写这个条件测试，使之工作正确。

解：
A. `size_t`为无符号整型，`maxbytes-sizeof(val)`中`maxbytes`被隐式转换为`unsigned`类型，所得结果也为无符号整型，恒为非负，即条件恒成立  
B. 
- 思路：
  将`sizeof`显示转换为int类型，然后做减法运算
- 代码：
```c
void copy_int(int val, void *buf, int maxbytes) {
    if (maxbytes - (int)sizeof(val) >= 0)
        memcpy(buf, (void*) &val, sizeof(val));
}
```