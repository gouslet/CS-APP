8.23 你的一个同事想要使用信号来让一个父进程对发生在子进程中的事件计数。其想法是每次发生一个事件时，通过向父进程发送一个信号来通知它，并且让父进程的信号处理程序对一个全局变量`counter`加一，在子进程终止之后，父进程就可以检查这个变量。然而，当他在系统上运行图8-
45中的测试程序时，发现当父进程调用`printf`时，`counter`的值总是`2`，即使子进程向父进程发送了`5`个信号也是如此。他很困惑，向你寻求帮助。你能解释这个程序有什么错误吗？

```c
#include "csapp.h"

int counter = 0;
void handler(int sig) {
    counter++;
    sleep(1); /* Do some work in the handler */
    return;
}

int main() {
    int i;
    
    Signal (SIGUSR2, handler);
    if (Fork() == 0) { /* Child */
        for (i = 0; i < 5; i ++) {
            Kill (getppid(), SIGUSR2);
            printf("sent SIGUSR2 to parent\n");
        }
        exit(0);
    }
    Wait (NULL);
    printf("counter=%d\n", counter);
    exit(0);
}
```
解：`Linux`内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。即当子进程执行`Kill (getppid(), SIGUSR2)`发送`SIGUSR2`信号给父进程，父进程调用`handler`处理程序时，后续发送的SIGUSR2信号均会被丢弃，也即只会执行一次`counter++`，因而最终会输出`counter=2`