8.26 以图`8-23`中的示例作为开始点，编写一个支持作业控制的`shell`程序。`shell`必须具有以下特性：
- 用户输入的命令行由一个`name`、零个或者多个参数组成，它们都由一个或者多个空格分隔开。
    - 如果`name`是一个内置命令，那么`shell`就立即处理它，并等待下一个命令行。
    - 否则，`shell`就假设`name`是一个可执行文件，在一个初始的子进程（作业）的上下文中加载并运行它。作业的进程组`ID`与子进程的`PID`相同。
- 每个作业是由一个进程`ID(PID)`或者一个作业`ID(JID)`来标识的，它是由一个`shell`分配的任意的小正整数。`JID`在命令行上用前缀`"%"`来表示。比如，`"%s"` 表示JID 5, 而`"5"`表示`PID 5`。
- 如果命令行以`&`来结束，那么`shell`就在后台运行这个作业。否则，`shell`就在前台运行这个作业。
- 输入`Ctrl+C(Ctrl+Z)` ，使得内核发送一个`SIGINTC SIGTSTP`) 信号给`shell`, `shell`再转发给前台进程组中的每个进程e
- 内置命令`jobs`列出所有的后台作业。
- 内置命令`bg job`通过发送一个`SIGCONT`信号重启`job`, 然后在后台运行它。`job`参数可以是一个`PID`, 也可以是一个`JID`。
- 内置命令`fg job`动通过发送一个`SIGCONT`信号重启job, 然后在前台运行它。
- `shell`回收它所有的僵死子进程。如果任何作业因为收到一个未捕获的信号而终止，那么`shell`就输出一条消息到终端，消息中包含该作业的`PID`和对该信号的描述。

`8-46`展示了一个`shell`会话示例。
```shell                
linux>./shell            Run your shell program
>bogus
bogus: Command not found.
>foo 10
Job 5035 terminated by signal: Interrupt `User types Ctrl +C`
>foo 100 &
[1] 5036 foo 100 &
>foo 200 &
>jobs
[1] 5036 Running foo 100 &
[2] 5037 foo 200 &
>fg %1
Job [1] 5036 stopped by signal: Stopped User types Ctrl+Z
Execve can't find executable 
[2] 5037 Running foo 200 &
>jobs
[1] 5036 Stopped foo 100 &
[2] 5037 Running foo 200 &
>bg 5035
5035: No such process
>bg 5036
[1] 5036 foo 100 &
>/bin/k辽1 5036
Job 5036 terminated by signal: Terminated
> fg %2 Wait for fg job to finish
>quit
l inux> Back to the Un 工x shell
```