2.58 编写过程is_little_endian,当在小端法机器上编译和运行时返回1 ，在大端法机器上编译运行时则返回0。这个程序应该可以运行在任何机器上，无论机器的字长是多少。

### 方法1：

- 设`int a = 1;` `a`存在`0x100`处，让`char *p=&a;` 则`p`指向`0x100`处，`*p`表示`0x100`处取一个字节。
    - 那么，如果机器是大端模式，则`0x100`处那个字节应该是`0`(低地址存高位)；
    - 如果机器是小端模式，则`0x100`处那个字节应该是1(低地址存低位)。

### 方法2：

- 利用联合体“每个成员公用一段共同空间”的性质，
    - 假设`union{short a;char b}test; test.a=1;`
    - 假设`a`成员存在`0x100`处，而联合体中成员公用一段相同的空间，则另一个成员`b`的存放位置也是`0x100`，则读取`test.b`，
        - 若为1则为小端；
        - 若为0则为大端。

### 方法3：

- 利用`gets()`函数缓冲区溢出的原理：
    - 先设变量`unsigned short a=0；char name[1];`
    - 之后用`gets()`函数从标准输入读取字符串装入`name`，故意输入两字节数据，那么，由于`name`本身空间不足，而且`gets`没有边界检查，于是输入字符串第二个字节会写入下个地址，也就是`a`变量首地址中那个字节（因为栈是向着地址变小的方向增长的，故`name`存放地址之后是`a`存放地址）。
- 于是`a`地址第一个字节有数字了，第二个字节仍是0。
    - 如果a是大端模式，则`a`应该`>=(USHRT_MAX+1)/2` 即高位字节有数字了；
    - 否则为小端模式，即低位字节有数字了。

三种方式代码如下
    
    #include <stdio.h>
    #include <limits.h>
    void method1(){
        int a=1;
        char *p=&a;
        if(*p)
            printf("小端\n");
        else
            printf("大端\n");
    }

    union Test{
        short a;
        char b;
    };

    void method2(){
        union Test test;
        test.a=1;
        if(test.b)
            printf("小端\n");
        else
            printf("大端\n");
    }

    void method3(){
        unsigned short limit=(USHRT_MAX+1)/2;
        unsigned short a=0;
        char name[1];
        printf("输入2字节字符串！\n");
        gets(name);
        if(a>=limit)
            printf("大端\n");
        else
            printf("小端\n");
    }

    main(){
        method1();
        method2();
        method3();
    }