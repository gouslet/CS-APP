2.37 现在你有一个任务，当数据类型int和size_t 都是32位的，修补上述旁注给出的XDR 代码中的漏洞。你决定将待分配字节数设置为数据类型uint64_t,来消除乘法溢出的可能性。你把原来对malloc 函数的调用（第9 行）替换如下：

    uint64_t asize = ele_cnt * (uint64_t) ele_size;
    void *result= malloc(asize);
提醒一下， malloc的参数类型是size_t。  

A. 这段代码对原始的代码有了哪些改进？  
解：上述改动不能消除漏洞，因为malloc的参数类型是size_t，也就是32位的无符号整数，调用malloc时会将64位的无符号整型asize转换为size_t类型，此时会发生截断，分配的内存可能小于asize，依然可能导致后续相同的问题。

B. 你该如何修改代码来消除这个漏洞？  
解：malloc使用一个32位无符号数作为参数，它分配的内存大小不会超过32位无符号整型所表达的最大整数$2^{32}$字节，所以应该在试图复制超过$2^{32}$字节的数据时直接失败，即可修正为

    uint64_t required_size = ele_cnt * (uint64_t) ele_size;
    size_t request_size = (size_t)required_size;
    if (required_size != request_size)
        return NULL;
    void *result= malloc(asize);
    if (result == NULL)
        return NULL;